C与C++的区别
摘要：C 是一种结构化语言，其重点在于算法和数据结构。C 程序设计首要考虑如何通过一个过程，对输入或环境条件进行运算处理得到输出或实现过程控制，而C++ 首要考虑如何构造一个对象模型，让这个模型能契合与之对应的问题域，这样就可通过获取对象的状态信息得到输出或实现过程控制。
关键字：C,C++，面向对象，面向结构
1 编程思想
C++ 与 C 语言最大的区别在于编程思想的截然不同，前者是面向对象的编程语言，后者则是面向过程的结构化的编程语言。面向对象程序语言将程序设计领域与日常生活拉得更近，面向过程的 C 语言强调程序的功能，以函数为中心，C++ 在 C 语言这一强大巨人的肩膀上发展，通过 C 语言强大的软硬件控制功能，融入面向对象的编程思想，强调程序的分层、分类，以抽象的类为基础，进行对象的定义与展示，使应用程序具有封装性、继承性和多态性。
2关键字
C 语言中的关键字几乎都可以在 C++中使用，但C++中增加了一些C语言中所不支持的关键字，这些关键字能够作为函数和变量的标识符在C程序中使用，尽管C++包含了所有的C，很显然没有任何C++编译器能够编译这样的 C 程序。例如 C++ 中的ne w和 delete 取 代 了 C 中 的 malloc 和fre e，C++ 中还增加了 public、private、try、c a tc h、throw等很多关键字。
3语法格式
C++和 C 语言在语法格式上也有很大的不同。C 程序员可以省略函数的返回类型，C++却不可以，即使无返回也应加上 void 类型。在 C 语言中输入输出是使用 scanf和 printf 函数来实现的，而 C++ 是使用类来实现的，C++ 中用于控制 I/O 的 iostream 类库替代了 C 语言中的 stdio 函数库。C++ 中的try/c a tc h/throw 异常处理机制取代了 C中的 setjmp 和 longjmp 函数。C++ 中的引用简化了C 语言中过于繁杂的指针。
4在字符的处理上
在 C 语言中没有字符常量, 而在 C++中有字符常量, 可以用这样的代码来验证:printf("%d\n", sizeof('a'));用 C 语言编译, 输出的结果是 sizeof(int)的值, 而用 C++编译, 输出的是 1。
5 C++中对指针使用的一些限制
在指针的使用上, C++对类型的要求是非常严格的, C++中void* 类型变量不能直接被赋值给某个指针变量, 而需要强制转换。如:int *p;void *s;p = s;在 C 语言中是可以编译通过的, 在 C++编译器处理的时候会出现编译错误。另外, C++中 void * 类型是不能进行指针算术运算的。比如上例中, 表达式:s + 1;在 C++中是不合法的, 而在 C 语言中是合法的, 与(void *)((int)s + 1);等价。C++中不允许指针的减法, 而在 C 语言中, 指针的减法是可以的。例如:int a, b;在 C 语言中, &b - &a 的值为((int)&b - (int)&a) / sizeof(int),在 C++中, 这样用就是错的。
6 引用(Reference)的出现与函数使用
6.1 引用
引用的出现主要是为了支持运算符的重载。不过他在函数调用方面也有不小的好处。通常, 在 C 语言中, 想要改变参数的值可以通过传递指针来实现, 现在, 有了引用, 这样的做法显得很方便。比如:int f(int &a){return ++a;}f(b);上面, 当 f(b);执行完, y 的值增加了 1, 在 C 语言中, 我们会这么做:int f(int *a){return ++(*a);}
6.2 函数使用
在函数使用的一些规则方面, C++与 C 是有很大不同的。通常, 我们这样定义函数:type function_name (parameter list) {declarations statements}这种方法不论在 C 语言还是在 C++中都适用。但是 C 语言中有一些是可省略的, 比如, type, 默认为 int, 而 C++中不可以省略。另外, parameter list 可以不指定变量的数据类型, 而在 pa-rameter list 与 declarations 之间定义参数的类型, 例如:f(a) int a;{ }这在 C 语言中是允许的, 但是, C++里会出现这样的编译错误:'a' was not declared in this scopeISO C++ forbids declaration of 'f' with no typesyntax error before 'int'另一个规则方面的不同是, 对于没有 parameter list 的解释,C 语言认为, 这样的 parameter list 表示这个函数可以有任意多个任意类型的参数。但是 C++则认为, 这样的 parameter list 表示这个函数没有任何参数。当然, C++的这种解释, C 语言可以把parameter list 定为 void。还有一点不同的是, 在 C 语言中虽然函数定义了返回类型(type) , 但是函数可以不返回任何类型。比如:int f(int x){return ;}而在 C++中编译的时候会有这样的错误提示: return -statement with no value, in function declared with a non- void re-turn type简言之, 在函数类型方面, C++要比 C 语言要严格, 而这种严格保证了函数重载可以出现在 C++中。 在 C 语言中函数可以没有函数声明而直接调用, 但是 C++要求调用函数之前必须声明函数。比如这样:int main(){f();return 0;}这样的程序在 C 语言中是不会出现编译错误的, 只不过, 如果这个函数在连接的库中没有定义, 连接的时候会说: "unde-fined symbol _f in module    " 但是, 在 C++中, 编译器会说: "'f' undeclared (first use this function)"。
7. 强制转换
C 语言提供了一种类型的强制转换, 形如(type)的方法, C++中保留了 C 语言的强制类型转换的方法, 对于相同功能的强制转换, C++还增加了一种很像函数调用的强制类型转换的方法,例如可以这样写:int x;long y;x = (int)y;在 C++中, 也可以写成:x = int(y);或许, 强制转换可以体现 C 语言的灵活性, 但是, 它也是一种很不安全的做法。C++增加了与强制转换有关的四个关键字,C++的以上四种转换在类上有很多应用, 比如, dynam-ic_cast 是主要应用于类的转换。而其他三种转换, 不涉及类时,与 C 语言对应类型转换在含义上没有太大区别, 是, 由于用了这样的关键字, 所以, C++程序员很容易在程序里找到相应的转换, 并且清楚是怎样转换的。
8 布尔运算与逻辑运算
在 C 语言中没有布尔类型, 一般布尔值就用整型代替了, 而C++增加了布尔类型 bool, 同时也增加常量 true 和 false。实际上, 逻辑类型的变量在程序设计中要经常用到, 而 C 语言的程序员也要经常用各种方法通过整型 "造出"布尔类型。于是, C++索性就增加了 bool 这种数据类型。用布尔运算符进行布尔逻辑运算, 布尔型变量或表达式的组合运算可以产生新的布尔值。具体运算符如下。而在有些人用的机器键盘上, 没有 &,|,^等键, 于是, C++增
加了一些关键字.
9. struct 含义的转变
对 C 语言中的结构体 struct 来说, 在 C++中它已经变成了类 class, 只不过 struct 默认成员是公用的(public) , 而 class 默认成员是私用的(private) 。于是, struct 在 C 和 C++中的含义也不同了。比如:struct{int x, y;int fun(int);};这个定义在 C 语言中是不合法的, 因为 C 语言与 C++ 不同, 无法使用 struct 关键字声明类。在 C 语言 中, 类与结构在语义上是不同的。struct( 结构) 是值类型, 而 class( 类) 是引用类型。而在 C++中是合法的。C++增加了 class 类后, 仍保留了结构体类型(struct) 和共用体类型(union) , 而且把它们的功能也扩展了, 允许在声明的结构体和共用体类型中包括成员函数, 也就是可以用 struct 和 u-nion 来声明一个类型。但它们和 class 声明的类有所区别。用 struct 声明的类, 如果不作 private( 私有的) 和 public( 公用的)声明, 系统将其成员默认定为 public,在需要时可以自己用显式声明重新指定为 private 或 public。用 union 声明的类, 如果不作 private 或 public 声明, 系统将其成员默认定为 public, 且不能改变。
10 堆与栈的区别
1.先看一个有关链表的简单程序:
【程序一】:
#include “stdio.h”
typedef struct node{int data;
struct node *next;
}lnode,*nodelist;
nodelist creatlis(t nodelist l, intn)
{nodelist s; intl;
fo(r i=0; i<n; i++)
{s=( nodelist) malloc( sizeo(f lnale)) ;
scan(f ”%d”, &s- > data) ;
s- >next=l- > next; l- >next=s;
}
return l;
}
void printnode( nodelist l)
{nodelist p=l- > next;
while(p)
{printf(”%d”, p- > data);
p=p- > next;
}
}
main( )
{nodelist head; int x:
scanf("%d", &x);
head=(nodelist)malloc(sizeof(1node));
head- >next=NULL;
head=creatlist(head, x);
printnode(head);
}
在这个程序中, 主函数 main( ) 调用函数 createlis(t ) 创建了一个长度为 x 的链表, 然后函数 printnode( ) 输出链表中各结点。但问题是, 当被调函数执行完回到主调函数时, 其被调用时所分配的空间将全部释放, createlis(t ) 和 printnode( ) 同为 main( ) 的被调函数, createlis(t ) 中创建的链表在返回 main( ) 后应不再存在了, 那么用 printnode( ) 输出肯定是错误的。显然, 程序是有问题的。但事实上, 该程序可以正常运行并输出结果。出现以上问题的原因, 就是编程者没有正确理解 C语言中的堆空间( heap) 和栈空间( stack) 。
2 正确理解“堆”和“栈”
在 C/ C++ 中我们常提到堆栈, 其实堆和栈是不同的存储空间。一般, C/ C++ 编译的程序占用的内存可分为: 程序代码区, 静态存储区和动态存储区。堆和栈都位于动态存储区, 但二者有诸多不同。栈空间是静态分配的, 如: 函数的参数、局部变量等, 系统会根据其大小预先在栈中自动分配适当的内存空间, 这一部分在其生存期内是固定不变的。而堆
空间是动态分配, 程序员可根据需要申请并指明大小, 不用时可释放收回, 如在 c 中用 malloc( ) 函数或在 c++ 中用 new运算符申请的空间。另外, 栈是由高地址向低地址扩展的数据结构, 是一块连续的内存区域。也就是说栈的最大容量是系统预先定好的, 在 Windows 下栈的大小是 2M( 系统不同, 栈的大小也可能不同, 总之是一个在编译时就确定的常数) , 如果申请的空间超过栈的剩余空间, 将提示 Overflow!所以, 能从栈获得的空间较小。而堆是一种由低地址向高地址扩展的数据结构,可以是不连续的内存空间( 操作系统用链表来存储空闲的内存地址) 。堆的大小只受限于计算机系统中有效的虚拟内存大小( 理论上足够大) 。由此可见, 堆的空间比较灵活, 也比较大。
3 堆和栈的应用举例
【程序二】:
#include”stdio.h”
int max( int x,int y)
{int z;
i(f x>y) z=x; else z=y;
return z;
}
main( )
{int a, b, c;
scanf("%d%d", &a, &b);
c=max(a,b);
printf("Max=%d”, c);
}
程序二在栈中的空间分配过程: 开始时栈为空栈, 程序执行, 系统调用 main( ) 函数, 为 main( ) 函数开辟栈空间, 用于存放操作系统的当前状态和返回地址, 以及局部变量 a、b、c。当执行到语句 c=max( a,b) 时, 则调用函数 max( ) , 这时又要在栈中为 max( ) 函数开辟栈空间, 用于存放 main( ) 函数当前状态和返回地址, 以及形参 x、y 和局部变量 z。当 max( ) 执行完后, 要释放刚才分配给 max( ) 函数的栈空间, 到了 main( ) 执行完时, 则要释放分配给 main( ) 函数的栈空间, 这时栈又为空栈。程序使用栈这种存储空间分配方式, 虽然有效地解决内存的高效利用问题, 但还不能满足实际的需要。如, 当某些数据是否需要、何时需要、需要多少, 只有在程序运行中才能确定, 这要求在运行时能进行动态分配和释放空间的机制来完成, C/C++ 中利用堆来实现这种机制。堆也位于动态存储区, 在程序执行期间通过动态分配函数或运算符获得堆部分的空闲存储空间, 不需要时利用相关函数或运算符释放空间。malloc/free 是 C/C++ 语言的标准库函数, new/delete 是 c++ 的运算符, 它们都可用于申请动态内存和释放内存。我们再来看一个程序。
【程序三】:
main( )
{int a, b, *p, *q;
scan(f ”%d%d”, & a, &b) ;
p=( int*) malloc( sizeo(f int)) ;
q=( int*) malloc( sizeo(f int)) ;
*p=a; *q=b;
print(f "%d %d\n", *p, *q) ;
free( p) ; free( q) ;
print(f "a=%d b=%d\n", a, b) ;
}
程序中, 通过 malloc 函数在堆空间中分配了两个整型空间, 并将空间的首地址赋值给 p、q, 即 p、q 指向所分配空间的首地址; 然后将 a 和 b 的值分别赋给这两个空间, 并输出; 使用完后, 利用 free 函数释放分配的空间。在这个程序中, 不仅使用了堆, 而且还使用了栈。当系统调用 main( ) 函数时, 则在栈中分配空间, 存放系统相关信息以及局部变量 a、b 和指针变量 p、q。当整个程序执行完时, 这些空间才被释放。可见, a、b 和 p、q 这些变量是存放在栈中的, 在程序执行时便分配了空间; 而在程序执行期间, 又在堆中分配了两个整型空间, 使用完后释放 ( 此时程序还没结束) 。在这时应注意的是: 如果不释放动态分配的空间, 程序执行完后, 空间仍然被占, 浪费了堆空间, 这些空间不能被再利用, 这就造成了“内存泄漏”。了解这些后, 我们回头再看程序一, 先前的疑问便迎刃而解了。在 main( ) 和 creatlis(t ) 中都利用 malloc 函数在堆中获得结点空间, 并将这些结点连接成带头结点的单链表, 由于 creatlis(t ) 结束时, 没有及时释放分配的堆空间, 因此这个链表还存在于堆中, 从而后面的 printnode( ) 函数可以将其输出, 也就不足为怪了。
4 总结
C/C++ 语言中的堆和栈是动态存储区中两个不同的区域。栈是静态存储分配, 空间的分配和释放是在函数调用过程中由编译程序完成的, 程序执行过程中固定不变; 堆是动态存储分配, 空间的分配和释放是在程序执行期间, 根据需要申请或释放。综上所述, 我们在使用 C/C++ 语言编程时, 应正确掌握存储空间的不同分配方式, 合理地使用堆和栈。
引用
【1】	浅析C_与C语言的几点联系与区别_陈海蕊
【2】	浅析C语言与C_的差异_赵元庆
【3】	C_C_中堆与栈的区别和应用_张伟
C_C_的编程风格与强
